#!/usr/bin/env dnsjit

local log = require("dnsjit.core.log")
local l = log.new("drool")

local getopt = require("dnsjit.lib.getopt").new({
    { "c", nil, "", "", "?+" },
    { "l", nil, "", "", "?+" },
    { "L", nil, "", "", "?+" },
    { "f", nil, "", "", "?" },
    { "i", nil, "", "", "?+" },
    { "r", nil, "", "", "?+" },
    { "R", nil, "", "", "?" },
    { "n", nil, "", "", "?" },
    { "v", nil, 0, "", "?+" },
    { "V", nil, false, "", "?" },
})
local arg = getopt:parse()

local v = getopt:val("v")
if v > 0 then
    log.enable("warning")
end
if v > 1 then
    log.enable("notice")
end
if v > 2 then
    log.enable("info")
end
if v > 3 then
    log.enable("debug")
end

if getopt:val("help") then
    print[[
  -c [type:]config
                Specify the configuration to use, if no type is given then
                config expects to be a file. Valid types are file and text.
                Can be given multiple times and will be processed in the
                given order. See drool.conf(5) for configuration syntax.
  -l facility[:level]
                Enable logging for facility, optional log level can be given
                to enable just that. Can be given multiple times and will be
                processed in the given order. See drool(1) for available
                facilities and log levels.
  -L facility[:level]
                Same as -l but to disable the given facility and log level.
  -f filter     Set the Berkeley Packet Filter to use.
  -i interface  Capture packets from interface, can be given multiple times.
  -r file.pcap  Read packets from PCAP file, can be given multiple times.
  -R mode       Specify the mode for reading PCAP files, see drool(1) for
                available modes.
  -n            Dry run mode, do not allocate any outbound sockets or
                generate any network traffic.
  -v            Enable verbose, a simple way to enable logging. Can be
                given multiple times to increase verbosity level.
  -h            Print this help and exit
  -V            Print version and exit
]]
    return
elseif getopt:val("V") then
    print("drool v@PACKAGE_VERSION@")
    return
end

files = {}
interfaces = {}
bpf = nil
client_pools = nil
host = nil
port = nil
max_clients = nil
client_ttl = nil
skip_reply = nil
max_reuse_clients = nil
sendas = nil
timing_mode = nil
timing_arg = nil
facility_log = {
    input = {},
    processing = {},
    network = {},
}

function enable_log(_, facility, level)
    local facility_ok = false
    if level == nil then
        level = "all"
    end

    l:info("enable log facility %s level %s", facility, level)

    if facility == "all" then
        if level == "debug" then
            log.enable("debug")
        elseif level == "info" then
            log.enable("info")
        elseif level == "notice" then
            log.enable("notice")
        elseif level == "warning" then
            log.enable("warning")
        elseif level == "all" then
            log.enable("debug")
            log.enable("info")
            log.enable("notice")
            log.enable("warning")
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "core" or facility == "all" then
        if level == "debug" then
            l:enable("debug")
        elseif level == "info" then
            l:enable("info")
        elseif level == "notice" then
            l:enable("notice")
        elseif level == "warning" then
            l:enable("warning")
        elseif level == "all" then
            l:enable("debug")
            l:enable("info")
            l:enable("notice")
            l:enable("warning")
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "input" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["input"], { "enable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "processing" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["processing"], { "enable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "network" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["network"], { "enable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if not facility_ok then
        l:fatal("invalid facility: %s", facility)
    end
end
function disable_log(_, facility, level)
    local facility_ok = false
    if level == nil then
        level = "all"
    end

    l:info("disable log facility %s level %s", facility, level)

    if facility == "all" then
        if level == "debug" then
            log.disable("debug")
        elseif level == "info" then
            log.disable("info")
        elseif level == "notice" then
            log.disable("notice")
        elseif level == "warning" then
            log.disable("warning")
        elseif level == "all" then
            log.disable("debug")
            log.disable("info")
            log.disable("notice")
            log.disable("warning")
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "core" or facility == "all" then
        if level == "debug" then
            l:disable("debug")
        elseif level == "info" then
            l:disable("info")
        elseif level == "notice" then
            l:disable("notice")
        elseif level == "warning" then
            l:disable("warning")
        elseif level == "all" then
            l:disable("debug")
            l:disable("info")
            l:disable("notice")
            l:disable("warning")
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "input" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["input"], { "disable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "processing" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["processing"], { "disable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if facility == "network" or facility == "all" then
        if level == "debug" or level == "info" or level == "notice" or level == "warning" or level == "all" then
            table.insert(facility_log["network"], { "disable", level })
        else
            l:fatal("invalid log level: %s", level)
        end
        facility_ok = true
    end

    if not facility_ok then
        l:fatal("invalid facility: %s", facility)
    end
end

conf = require("dnsjit.lib.parseconf").new()
conf:func("log", enable_log)
conf:func("nolog", disable_log)
conf:func("read", function(_, file)
    table.insert(files, file)
end)
conf:func("input", function(_, interface)
    table.insert(interfaces, interface)
end)
conf:func("filter", function(_, arg1)
    bpf = arg1
end)
conf:func("timing", function(_, mode, arg1)
    if mode == "ignore" then
        return
    elseif mode == "keep" or mode == "best_effort" or mode == "increase" or mode == "reduce" or mode == "multiply" then
        timing_arg = arg1
    else
        l:fatal("unknown timing mode: %s", mode)
    end
end)
conf:func("context", function(_, option, arg1)
    if option == "client_pools" then
        client_pools = arg1
    else
        l:fatal("unknown context option: %s", option)
    end
end)
conf:func("client_pool", function(_, option, arg1, arg2)
    if option == "target" then
        host = arg1
        port = arg2
    elseif option == "max_clients" then
        max_clients = arg1
    elseif option == "client_ttl" then
        client_ttl = arg1
    elseif option == "skip_reply" then
        skip_reply = true
    elseif option == "max_reuse_clients" then
        max_reuse_clients = arg1
    elseif option == "sendas" then
        sendas = arg1
    else
        l:fatal("unknown client_pool option: %s", option)
    end
end)

local k, v, o

o = getopt:val("c")
if type(o) == "string" then
    if o > "" then
        o = { o }
    else
        o = {}
    end
end
for k, v in pairs(o) do
    local t = v:sub(1, 5)
    if t == "text:" then
        conf:line(v:sub(6))
    elseif t == "file:" then
        conf:file(v:sub(6))
    else
        l:fatal("unknown conf type: %s", v:sub(1,4))
    end
end

o = getopt:val("l")
if type(o) == "string" then
    if o > "" then
        o = { o }
    else
        o = {}
    end
end
for k, v in pairs(o) do
    local n = v:find(":")
    print(v, n)
    if n == nil then
        enable_log(nil, v)
    else
        enable_log(nil, v:sub(1,n), v:sub(n+1))
    end
end

o = getopt:val("L")
if type(o) == "string" then
    if o > "" then
        o = { o }
    else
        o = {}
    end
end
for k, v in pairs(o) do
    local n = v:find(":")
    if n == nil then
        disable_log(nil, v)
    else
        disable_log(nil, v:sub(1,n), v:sub(n+1))
    end
end

read_iter = 1
read_mode = false
o = getopt:val("R")
if o > "" then
    if o:sub(1,5) == "iter:" then
        read_iter = tonumber(o:sub(6))
    elseif o == "loop" then
        read_loop = true
    else
        l:fatal("unknown read mode: %s", o)
    end
end

function set_log(facility, obj)
    local v
    for _, v in pairs(facility_log[facility]) do
        local what, level = unpack(v)
        if what == "enable" then
            if level == "debug" then
                obj:log():enable("debug")
            elseif level == "info" then
                obj:log():enable("info")
            elseif level == "notice" then
                obj:log():enable("notice")
            elseif level == "warning" then
                obj:log():enable("warning")
            elseif level == "all" then
                obj:log():enable("debug")
                obj:log():enable("info")
                obj:log():enable("notice")
                obj:log():enable("warning")
            end
        elseif what == "disable" then
            if level == "debug" then
                obj:log():disable("debug")
            elseif level == "info" then
                obj:log():disable("info")
            elseif level == "notice" then
                obj:log():disable("notice")
            elseif level == "warning" then
                obj:log():disable("warning")
            elseif level == "all" then
                obj:log():disable("debug")
                obj:log():disable("info")
                obj:log():disable("notice")
                obj:log():disable("warning")
            end
        end
    end
end

function run()
    local input = require("dnsjit.input.pcap").new()
    set_log("input", input)
    input:only_queries(true)

    o = getopt:val("f")
    if o > "" then
        bpf = f
    end
    if bpf and bpf > "" then
        input:filter(bpf)
    end

    o = getopt:val("i")
    if type(o) == "string" then
        if o > "" then
            o = { o }
        else
            o = {}
        end
    end
    for k, v in pairs(interfaces) do
        input:open(v)
    end
    for k, v in pairs(o) do
        input:open(v)
    end

    o = getopt:val("r")
    if type(o) == "string" then
        if o > "" then
            o = { o }
        else
            o = {}
        end
    end
    for k, v in pairs(files) do
        input:open_offline(v)
    end
    for k, v in pairs(o) do
        input:open_offline(v)
    end

    function new_output()
        local output = require("dnsjit.output.cpool").new(host, port)
        set_log("network", output)
        if max_clients ~= nil then
            output:max_clients(max_clients)
        end
        if client_ttl ~= nil then
            output:client_ttl(client_ttl)
        end
        if skip_reply ~= nil then
            output:skip_reply(skip_reply)
        end
        if max_reuse_clients ~= nil then
            output:max_reuse_clients(max_reuse_clients)
        end
        if sendas ~= nil then
            output:sendas(sendas)
        end
        output:dry_run(getopt:val("n"))
        return output
    end

    function new_timing()
        local timing = require("dnsjit.filter.timing").new()
        set_log("processing", timing)
        if timing_mode == "keep" or timing_mode == "best_effort" then
            timing:keep()
        elseif mode == "increase" then
            timing:increase(timing_arg)
        elseif mode == "reduce" then
            timing:reduce(timing_arg)
        elseif mode == "multiply" then
            timing:multiply(timing_arg)
        end
        return timing
    end

    if client_pools == nil or client_pools == 1 then
        local output = new_output()
        if timing_mode then
            local timing = new_timing()
            input:receiver(timing)
            timing:receiver(output)
        else
            input:receiver(output)
        end
        output:start()
        input:run()
        output:stop()
    else
        local n
        local outputs = {}
        local roundrobin = require("dnsjit.filter.roundrobin").new()
        set_log("processing", roundrobin)
        for n = 1, client_pools do
            local output = new_output()
            if timing_mode then
                local timing = new_timing()
                roundrobin:receiver(timing)
                timing:receiver(output)
            else
                roundrobin:receiver(output)
            end
            table.insert(outputs, output)
        end
        input:receiver(roundrobin)
        for _, o in pairs(outputs) do
            o:start()
        end
        input:run()
        for _, o in pairs(outputs) do
            o:stop()
        end
    end

    local start_sec, start_nsec, end_sec, end_nsec, runtime

    start_sec, start_nsec = input:start_time()
    end_sec, end_nsec = input:end_time()
    runtime = 0
    if end_sec > start_sec then
        runtime = ((end_sec - start_sec) - 1) + ((1000000000 - start_nsec + end_nsec)/1000000000)
    elseif end_sec == start_sec and end_nsec > start_nsec then
        runtime = (end_nsec - start_nsec) / 1000000000
    end

    print("runtime", runtime)
    print("packets", input:packets(), input:packets()/runtime, "/pps")
    print("queries", input:queries(), input:queries()/runtime, "/qps")
    print("dropped", input:dropped())
    print("ignored", input:ignored())
    print("total", input:queries() + input:dropped() + input:ignored())
end

if read_loop then
    while true do
        run()
        collectgarbage()
    end
else
    for iter = 1, read_iter do
        run()
        collectgarbage()
    end
end
